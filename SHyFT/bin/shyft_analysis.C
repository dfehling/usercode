#include "DataFormats/FWLite/interface/Handle.h"
#include "DataFormats/FWLite/interface/Event.h"
#include "PhysicsTools/FWLite/interface/EventContainer.h"
#include "PhysicsTools/FWLite/interface/CommandLineParser.h" 
#include "PhysicsTools/SelectorUtils/interface/WPlusJetsEventSelector.h"
#include "Math/GenVector/PxPyPzM4D.h"
#include "FWCore/FWLite/interface/AutoLibraryLoader.h"
#include "PhysicsTools/FWLite/interface/TFileService.h"
#include "FWCore/PythonParameterSet/interface/PythonProcessDesc.h"
#include "FWCore/ParameterSet/interface/ProcessDesc.h"

#include <iostream>
#include <cmath>      //necessary for absolute function fabs()
#include <boost/shared_ptr.hpp>
#include <boost/lexical_cast.hpp>

//Root includes
#include "TROOT.h"
#include "TFile.h"
#include "TH1.h"
#include "TH2.h"
#include "TCanvas.h"
#include "TLegend.h"
#include "TSystem.h"
#include "TStopwatch.h"

using namespace std;

enum
{
   kNormalMode,
   kVqqMode,
   kLFMode,
   kWcMode
};


// TODO: bring the isolation plots back to life 

typedef std::vector<reco::ShallowClonePtrCandidate> ShallowCloneCollection;


class Preselection {

  public:
    Preselection(edm::ParameterSet const &);
    virtual bool filter(const edm::EventBase& iEvent);

protected:
  edm::InputTag trigSrc_;
};
   

Preselection::Preselection(edm::ParameterSet const & params ) :
  trigSrc_( params.getParameter<edm::ParameterSet>("shyftAnalysis").getParameter<edm::InputTag>("trigSrc") )
{;}


bool
Preselection::filter(const edm::EventBase& iEvent){
  bool passTrig = false;
  edm::Handle<pat::TriggerEvent> triggerEvent;
  iEvent.getByLabel(trigSrc_, triggerEvent);
  if ( triggerEvent->wasRun() && triggerEvent->wasAccept() ) {
      pat::TriggerPath const * muPath = triggerEvent->path("HLT_Mu9");
      pat::TriggerPath const * elePath = triggerEvent->path("HLT_Ele15_LW_L1R");

      if (muPath != 0 && muPath->wasAccept()) passTrig = true;    
      if (elePath != 0 && elePath->wasAccept()) passTrig = true;
  }
  return passTrig;
}



class SHyFT {

  public:
    SHyFT(const edm::ParameterSet& iConfig, TFileDirectory& iDir);
    virtual ~SHyFT() {}
    virtual void analyze(const edm::EventBase& iEvent);
    virtual void finalize();

  private:
    bool analyze_electrons(const std::vector<reco::ShallowClonePtrCandidate>& electrons);
    bool analyze_muons(const std::vector<reco::ShallowClonePtrCandidate>& muons);    
    bool analyze_jets(const std::vector<reco::ShallowClonePtrCandidate>& jets);
    bool calcSampleName (const edm::EventBase& iEvent, std::string &sampleName);

    WPlusJetsEventSelector wPlusJets;
    TFileDirectory& theDir;
    // 'registry' for the histograms                                                                                                                                                                    
    std::map<std::string, TH1F*> histograms;
    // the following parameters need to come from the config
    bool muPlusJets_;
    bool ePlusJets_;
    bool useHFcat_;
    int nJetsCut_ ;
    int mode;
    std::string sampleNameInput;
    // used to be a global, what a shit!
    int HFcat_;
    std::string secvtxname;
};


SHyFT::SHyFT(const edm::ParameterSet& iConfig, TFileDirectory& iDir) :
  wPlusJets(iConfig.getParameter<edm::ParameterSet>("shyftAnalysis")),
  theDir(iDir),
  muPlusJets_(iConfig.getParameter<edm::ParameterSet>("shyftAnalysis").getParameter<bool>("muPlusJets")),
  ePlusJets_(iConfig.getParameter<edm::ParameterSet>("shyftAnalysis").getParameter<bool>("ePlusJets")),
  useHFcat_(iConfig.getParameter<edm::ParameterSet>("shyftAnalysis").getParameter<bool>("heavyFlavour")),
  nJetsCut_(iConfig.getParameter<edm::ParameterSet>("shyftAnalysis").getParameter<int>("minJets")),  
  mode(iConfig.getParameter<edm::ParameterSet>("shyftAnalysis").getParameter<int>("mode")),
  sampleNameInput(iConfig.getParameter<edm::ParameterSet>("shyftAnalysis").getParameter<std::string>("sampleName"))
{
  //book all the histograms for muons
  histograms["muPt"]     = theDir.make<TH1F>("muPt",     "Muon p_{T} (GeV/c) ", 100,    0, 200);
  histograms["muEta"]    = theDir.make<TH1F>("muEta",    "Muon eta",             50, -3.0, 3.0);
  histograms["nHits"]    = theDir.make<TH1F>("nHits",    "Muon N Hits",          35,    0,  35);
  histograms["d0"]       = theDir.make<TH1F>("d0",       "Muon D0",              60, -0.2, 0.2);
  histograms["Chi2"]     = theDir.make<TH1F>("Chi2",     "Muon Chi2",            20,    0,   5);
  histograms["hCalVeto"] = theDir.make<TH1F>("hCalVeto", "Muon hCalVeto",        30,    0,  30);
  histograms["eCalVeto"] = theDir.make<TH1F>("eCalVeto", "Muon eCalVeto",        30,    0,  30);

  // book all the histograms for electrons
  histograms["ePt"]  = theDir.make<TH1F>("ePt",  "Electron p_{T} (GeV/c) ", 100,    0, 200);
  histograms["eEta"] = theDir.make<TH1F>("eEta", "Electron eta",             50, -3.0, 3.0);
  histograms["ePhi"] = theDir.make<TH1F>("ePhi", "Electron Phi",             50, -3.2, 3.2);
  histograms["eD0"]  = theDir.make<TH1F>("eD0",  "Electron D0",              60, -0.2, 0.2);

  std::vector<std::string> sampleNameBase;
  std::vector<std::string> sampleName;
  std::vector<std::string> secvtxName(5,"_secvtxMass_");
  secvtxName[0]+="1j_"; secvtxName[1]+="2j_"; secvtxName[2]+="3j_"; secvtxName[3]+="4j_"; secvtxName[4]+="5j_";
  
  std::vector<std::string> secvtxEnd;
  secvtxEnd.push_back("1t_b");  secvtxEnd.push_back("1t_c");  secvtxEnd.push_back("1t_q");
  secvtxEnd.push_back("1t_x");  secvtxEnd.push_back("1t");    secvtxEnd.push_back("2t_bb");
  secvtxEnd.push_back("2t_bc"); secvtxEnd.push_back("2t_bq"); secvtxEnd.push_back("2t_cc");
  secvtxEnd.push_back("2t_cq"); secvtxEnd.push_back("2t_qq"); secvtxEnd.push_back("2t");
  secvtxEnd.push_back("2t_xx");

  if(sampleNameInput=="Vqq") {
    sampleNameBase.push_back(sampleNameInput+"W");
    sampleNameBase.push_back(sampleNameInput+"Z");
    sampleNameBase.push_back(sampleNameInput+"X");
    for(int i=0;i<3;++i) {
      sampleName.push_back(sampleNameBase[i]+"bb");
      sampleName.push_back(sampleNameBase[i]+"b2");
      sampleName.push_back(sampleNameBase[i]+"cc");
      sampleName.push_back(sampleNameBase[i]+"c2");
    }
  }
  else if (sampleNameInput=="Wjets") {
    sampleName.push_back("Wjetsb3");
    sampleName.push_back("Wjetsc3");
  }
  else sampleName.push_back(sampleNameInput);

  //Calibration Plots
  histograms["trackIso"]      = theDir.make<TH1F>("trackIso", "TrackIso",                50,    0,   50);
  histograms["eCalIso"]       = theDir.make<TH1F>("eCalIso",  "eCalIso",                 80,    0,   40);
  histograms["hCalIso"]       = theDir.make<TH1F>("hCalIso",  "hCalIso",                 60,    0,   30);
  histograms["relIso"]        = theDir.make<TH1F>("relIso",   "RelIso",                  50,    0,    5);
  histograms["nJets"]         = theDir.make<TH1F>("nJets",    "N Jets, pt>30, eta<2.4",  15,    0,   15);
  histograms["jet1Pt"]        = theDir.make<TH1F>("jet1Pt",   "1st leading jet pt",     150,    0,  300);
  histograms["jet2Pt"]        = theDir.make<TH1F>("jet2Pt",   "2nd leading jet pt",     150,    0,  300);
  histograms["jet3Pt"]        = theDir.make<TH1F>("jet3Pt",   "3rd leading jet pt",     150,    0,  300);
  histograms["jet4Pt"]        = theDir.make<TH1F>("jet4Pt",   "4th leading jet pt",     150,    0,  300);
  histograms["jet1Eta"]       = theDir.make<TH1F>("jet1Eta",  "1st leading jet eta",     50, -3.0,  3.0);
  histograms["jet2Eta"]       = theDir.make<TH1F>("jet2Eta",  "2nd leading jet eta",     50, -3.0,  3.0);
  histograms["jet3Eta"]       = theDir.make<TH1F>("jet3Eta",  "3rd leading jet eta",     50, -3.0,  3.0);
  histograms["jet4Eta"]       = theDir.make<TH1F>("jet4Eta",  "4th leading jet eta",     50, -3.0,  3.0);
  histograms["jet1Mass"]      = theDir.make<TH1F>("jet1Mass", "1st leading jet mass",    50,    0,  150);
  histograms["jet2Mass"]      = theDir.make<TH1F>("jet2Mass", "2nd leading jet mass",    50,    0,  150);
  histograms["jet3Mass"]      = theDir.make<TH1F>("jet3Mass", "3rd leading jet mass",    50,    0,  150);
  histograms["jet4Mass"]      = theDir.make<TH1F>("jet4Mass", "4th leading jet mass",    50,    0,  150);
  histograms["bmass"]         = theDir.make<TH1F>("bmass",    "B Sec Vtx Mass",          28,    0,    7);
  histograms["cmass"]         = theDir.make<TH1F>("cmass",    "C Sec Vtx Mass",          28,    0,    7);
  histograms["lfmass"]        = theDir.make<TH1F>("lfmass",   "LF Sec Vtx Mass",         28,    0,    7);
  histograms["flavorHistory"] = theDir.make<TH1F>("flavorhistory", "Flavor History",     12,    0,   12);
  histograms["discriminator"] = theDir.make<TH1F>("discriminator", "BTag Discriminator", 30,    2,    8);
  histograms["nVertices"]     = theDir.make<TH1F>("nVertices",     "num sec Vertices",    5,    0,    5);
  /*  ev.add ( new TH1F( TString("beff_pt0to50"),    "0 non-b untag, 1 b untag, 2 non-b tag, 3 b tag",      4,    0,      4) );
  ev.add ( new TH1F( TString("beff_pt50to100"),  "0 non-b untag, 1 b untag, 2 non-b tag, 3 b tag",      4,    0,      4) );
  ev.add ( new TH1F( TString("beff_pt100to150"), "0 non-b untag, 1 b untag, 2 non-b tag, 3 b tag",      4,    0,      4) );
  ev.add ( new TH1F( TString("beff_pt150to200"), "0 non-b untag, 1 b untag, 2 non-b tag, 3 b tag",      4,    0,      4) );
  ev.add ( new TH1F( TString("beff_pt200to250"), "0 non-b untag, 1 b untag, 2 non-b tag, 3 b tag",      4,    0,      4) );
  ev.add ( new TH1F( TString("beff_pt250to300"), "0 non-b untag, 1 b untag, 2 non-b tag, 3 b tag",      4,    0,      4) );
  ev.add ( new TH1F( TString("beff_pt300plus"),  "0 non-b untag, 1 b untag, 2 non-b tag, 3 b tag",      4,    0,      4) );
  */
  histograms["tag_eff"]    = theDir.make<TH1F>("tag_eff", "0 lf untag, 1 c untag, 2 b untag, 3 lf tag, 4 c tag, 5 b tag", 6, 0, 6);
  histograms["tag_jet_pt"] = theDir.make<TH1F>("tag_jet_pt", "JetPt to go with tagging efficiency", 150,    0,    300);

  histograms[sampleNameInput+"_hT"]    = theDir.make<TH1F>( (sampleNameInput+"_hT").c_str(),    "HT using Et is the sum of Jet Et plus Muon Pt", 50, 0,  1200);
  histograms[sampleNameInput+"_hT_1j"] = theDir.make<TH1F>( (sampleNameInput+"_hT_1j").c_str(), "HT using Pt is the sum of Jet Et plus Muon Pt", 10,  50, 300);
  histograms[sampleNameInput+"_hT_2j"] = theDir.make<TH1F>( (sampleNameInput+"_hT_2j").c_str(), "HT using Pt is the sum of Jet Et plus Muon Pt", 10,  80, 500);
  histograms[sampleNameInput+"_hT_3j"] = theDir.make<TH1F>( (sampleNameInput+"_hT_3j").c_str(), "HT using Pt is the sum of Jet Et plus Muon Pt", 10, 110, 600);
  histograms[sampleNameInput+"_hT_4j"] = theDir.make<TH1F>( (sampleNameInput+"_hT_4j").c_str(), "HT using Pt is the sum of Jet Et plus Muon Pt",  5, 140, 600);
  histograms[sampleNameInput+"_hT_5j"] = theDir.make<TH1F>( (sampleNameInput+"_hT_5j").c_str(), "HT using Pt is the sum of Jet Et plus Muon Pt",  5, 170, 600);
  //histograms[sampleNameInput+"_hTvsNJet"] = theDir.make<TH2F>( (sampleNameInput+"_hTvsNJet").c_str(),  "HT as a function of NJets", 5, 0.5, 5.5, 50, 0, 1200);
  //ev.add ( new TH1F( sampleNameInput+TString("_hTUsingPt"), "HT s is Sum of Jet Pt", 50, 0, 1200) );

  for (unsigned int j=0;j<sampleName.size();++j) {
    for(unsigned int k=0;k<secvtxName.size();++k) {
      for(unsigned int l=0;l<secvtxEnd.size();++l) {
	std::string temp = sampleName[j]+secvtxName[k]+secvtxEnd[l];
        histograms[temp] = theDir.make<TH1F>(temp.c_str(), "secvtxmass", 40,    0,   10);
        if(k==0 && l==4) break;
      }
    }
  }

}


// fill the plots for the electrons
bool SHyFT::analyze_electrons(const std::vector<reco::ShallowClonePtrCandidate>& electrons)
{
  if ( electrons.size() == 0 )  return false;
  const pat::Electron * electron_ = dynamic_cast<const pat::Electron*>(&electrons[0]);
  double ePt_      = electron_ ->pt();
  double eEta_     = electron_ ->eta();
  double ePhi_     = electron_ ->phi();
  double eD0_      = electron_ ->dB();
  //double trackIso_ = electron_ ->trackIso();
  //double eCalIso_  = electron_ ->ecalIso();
  //double hCalIso_  = electron_ ->hcalIso();
  //double relIso_   = ( trackIso_ + eCalIso_ + hCalIso_ )/ePt_ ;

  histograms["ePt"]->Fill( ePt_ );
  histograms["eEta"]->Fill( eEta_ );
  histograms["ePhi"]->Fill( ePhi_ );
  histograms["eD0"]->Fill( eD0_ );

  return true;
}

// fill the plots for the muons
bool SHyFT::analyze_muons(const std::vector<reco::ShallowClonePtrCandidate>& muons)
{
  const pat::Muon * globalMuon = NULL;
  for ( ShallowCloneCollection::const_iterator muonBegin = muons.begin(),
          muonEnd = muons.end(), imuon = muonBegin;
        imuon != muonEnd; ++imuon ) {
    if ( imuon->isGlobalMuon() ) {
      globalMuon = dynamic_cast<const pat::Muon *>(imuon->masterClonePtr().get());
      break;
    }
  }

  if ( globalMuon == NULL ) {  cout<<"No Global Muon is found"<<endl; return false; }
  double muPt_       = globalMuon->pt();
  double muEta_      = globalMuon->eta();
  double nhits_      = static_cast<int>( globalMuon->numberOfValidHits() );
  double d0_         = globalMuon->dB();
  double norm_chi2_  = globalMuon->normChi2();
  double hCalVeto_   = globalMuon->isolationR03().hadVetoEt;
  double eCalVeto_   = globalMuon->isolationR03().emVetoEt;
  //double trackIso_   = globalMuon->trackIso();
  //double eCalIso_    = globalMuon->ecalIso();
  //double hCalIso_    = globalMuon->hcalIso();
  //double relIso_     = ( trackIso_ + eCalIso_ + hCalIso_ )/muPt_ ;

  histograms["muPt"]->Fill( muPt_      );
  histograms["muEta"]->Fill( muEta_     );
  histograms["nHits"]->Fill( nhits_     );
  histograms["d0"]->Fill( d0_        );
  histograms["Chi2"]->Fill( norm_chi2_ );
  histograms["hCalVeto"]->Fill( hCalVeto_  );
  histograms["eCalVeto"]->Fill( eCalVeto_  );

  return true;
}


// fill the plots for the jets
bool SHyFT::analyze_jets(const std::vector<reco::ShallowClonePtrCandidate>& jets)
{

  //SecVtxMass and b-tagging related quantities
  int numBottom=0,numCharm=0,numLight=0;
  int numTags=0, numJets=0;
  double sumVertexMass=0, vertexMass=0;
  for ( ShallowCloneCollection::const_iterator jetBegin = jets.begin(),
	  jetEnd = jets.end(), jetIter = jetBegin;
	jetIter != jetEnd; ++jetIter)
  {
      const pat::Jet* jet = dynamic_cast<const pat::Jet *>(jetIter->masterClonePtr().get());

      // We first get the flavor of the jet so we can fill look at btag efficiency.
      int jetFlavor = std::abs( jet->partonFlavour() );
      double jetPt  = std::abs( jet->pt() );
     
      histograms["tag_jet_pt"]->Fill( jetPt );

      // Is this jet tagged and does it have a good secondary vertex
      if( jet->bDiscriminator("simpleSecondaryVertexBJetTags") < 2.05 ) {
        // This jet is not tagged, so we skip it but first we check the btag efficiency.
        if     ( jetFlavor == 4 ) histograms["tag_eff"]-> Fill( 1 );
        else if( jetFlavor == 5 ) histograms["tag_eff"]-> Fill( 2 );
        else                      histograms["tag_eff"]-> Fill( 0 );
        continue;
      } 
      else {
        if     ( jetFlavor == 4 ) histograms["tag_eff"]-> Fill( 4 );
        else if( jetFlavor == 5 ) histograms["tag_eff"]-> Fill( 5 );
        else                      histograms["tag_eff"]-> Fill( 3 );
      }
      reco::SecondaryVertexTagInfo const * svTagInfos
        = jet->tagInfoSecondaryVertex("secondaryVertex");
      if ( svTagInfos->nVertices() <= 0 )  continue;
      else histograms["nVertices"]-> Fill( svTagInfos->nVertices() );

      // Calculate SecVtx Mass //
      ROOT::Math::LorentzVector< ROOT::Math::PxPyPzM4D<double> > sumVec;
      
      reco::Vertex::trackRef_iterator
        kEndTracks = svTagInfos->secondaryVertex(0).tracks_end();
      for (reco::Vertex::trackRef_iterator trackIter =
             svTagInfos->secondaryVertex(0).tracks_begin();
           trackIter != kEndTracks;
           ++trackIter )
        {
          const double kPionMass = 0.13957018;
	  ROOT::Math::LorentzVector< ROOT::Math::PxPyPzM4D<double> >  p4_1;
          p4_1.SetPx( (*trackIter)->px() );
          p4_1.SetPy( (*trackIter)->py() );
          p4_1.SetPz( (*trackIter)->pz() );
          p4_1.SetM (kPionMass);
          sumVec += p4_1;
          
        }  // for trackIter
      
      vertexMass = sumVec.M();
      sumVertexMass += vertexMass;

      //Here we determine what kind of flavor we have in this jet
      if ( useHFcat_ )
        histograms["flavorhistory"]-> Fill ( HFcat_ );

      switch (jetFlavor)
      {
        case 5:
          // bottom
          histograms["bmass"]->Fill(vertexMass);
          ++numBottom; 
        case 4:
          // charm
          histograms["cmass"]->Fill(vertexMass);
          ++numCharm;
        default:
          // light flavour
          histograms["lfmass"]->Fill(vertexMass);
          ++numLight;
      }
      ++numTags;
      histograms["discriminator"]-> Fill ( jet->bDiscriminator("simpleSecondaryVertexBJetTags") );
      
      // For now, we only care if we have 2 tags...any more are treated the same - maybe we should look at 3 tags?
      if(numTags==2) break;
  }

   // Calculate average SecVtx mass and //  
   // fill appropriate histograms.      //                                                                                                                                                            
   // TODO !!!
  numJets = std::min( (int) jets.size(), 5 );
  //histograms[secvtxname + "_jettag"]->Fill (numJets, numTags);

  sumVertexMass /= numTags;

  string whichtag = "";
  if (1 == numTags)
    {
      // single tag                                                                                                                                                                                                
      if      (numBottom)              whichtag = "_b";
      else if (numCharm)               whichtag = "_c";
      else if (numLight)               whichtag = "_q";
      else                             whichtag = "_x";
    }
  else {
    // double tags                                                                                                                                                                                                 
    if      (2 == numBottom)         whichtag = "_bb";
    else if (2 == numCharm)          whichtag = "_cc";
    else if (2 == numLight)          whichtag = "_qq";
    else if (numBottom && numCharm)  whichtag = "_bc";
    else if (numBottom && numLight)  whichtag = "_bq";
    else if (numCharm  && numLight)  whichtag = "_cq";
    else                             whichtag = "_xx";
  } // if two tags                                                                                                                                                                                                  
  string massName = secvtxname
    + Form("_secvtxMass_%dj_%dt", numJets, numTags);

  //  histograms[massName           ]-> Fill (sumVertexMass);
  //  histograms[massName + whichtag]-> Fill (sumVertexMass);


  return true;
}



///////////////////
/// The event loop
//////////////////
void SHyFT::analyze(const edm::EventBase& iEvent)
{

  std::strbitset ret = wPlusJets.getBitTemplate();

  bool passed = wPlusJets(iEvent, ret);
  std::vector<reco::ShallowClonePtrCandidate> const & electrons = wPlusJets.selectedElectrons();
  std::vector<reco::ShallowClonePtrCandidate> const & muons     = wPlusJets.selectedMuons();
  std::vector<reco::ShallowClonePtrCandidate> const & jets      = wPlusJets.cleanedJets();
  //std::vector<reco::ShallowClonePtrCandidate> const & jetsBeforeClean = wPlusJets.selectedJets();

  string bit_;

  bit_ = "Trigger" ;
  bool passTrigger = ret[ bit_ ];
  bit_ = "== 1 Lepton";
  bool passOneLepton = ret[ bit_ ];

  // if not passed trigger, next event                                                                                                                                                                       
  if ( !passTrigger )  return;

  secvtxname = "";
  //find the sample name
  if(!calcSampleName(iEvent, secvtxname) ) return;

  // TODO: check the logic !
  // TODO: integrate the secvtxname initialization 

  if (passed) 
  {
    analyze_jets(jets);
    if ( muPlusJets_ ) analyze_muons(muons);
    if ( ePlusJets_ ) analyze_electrons(electrons);

    if( !passOneLepton ) return;

    histograms["nJets"]->Fill( jets.size() );
    unsigned int maxJets = jets.size();
    if ( maxJets >= nJetsCut_ ) {
      if ( maxJets > 4 ) maxJets = 4;
      for ( unsigned int i=0; i<maxJets; ++i) {
	histograms["jet" + boost::lexical_cast<std::string>(i+1) + "Pt"] ->Fill( jets[i].pt()  );
	histograms["jet" + boost::lexical_cast<std::string>(i+1) + "Eta"]->Fill( jets[i].eta() );
      }
    }
    return;

  }
  
}

bool SHyFT::calcSampleName (const edm::EventBase& iEvent, std::string &sampleName)
{
    // Get the heavy flavor category - we first want to make sure we have flavorHistory
    if(useHFcat_) {
      edm::Handle< unsigned int > heavyFlavorCategory;
      iEvent.getByLabel ( edm::InputTag("flavorHistoryFilter"),heavyFlavorCategory);
      assert ( heavyFlavorCategory.isValid() );
      HFcat_ = (*heavyFlavorCategory);

	// Light Flavor Mode //
	if (kLFMode == mode)
	  {
	    // Wqq
	    if (5 == HFcat_)
	      {
		sampleName += "b3";
	      }
	    else if (6 == HFcat_)
	      {
		sampleName += "c3";
	      }
	    else if (11 != HFcat_)
	      {
		// skip this event
		return false;
	      } // else if ! 11
	    return true;
	  }
    
	// Wc Mode //
	if (kWcMode == mode)
	  {
	    // Wc
	    if (4 != HFcat_)
	      {
		// skip this event
		return false;
	      } // if not Wc
	    return true;
	  } // else if Wc
    
	// Vqq Mode //
    
	// MadGraph (at least as CMS has implemented it) has this _lovely_
	// feature that if the W or Z is far enough off-shell, it erases
	// the W or Z from the event record.  This means that in some
	// number of cases, we won't be able to tell whether this is a W or
	// Z event by looking for a W or Z in the GenParticle collection.
	// (We'll eventually have to be more clever).
	//   sampleName = "X";
	edm::Handle< vector< reco::GenParticle > > genParticleCollection;
	iEvent.getByLabel (edm::InputTag("prunedGenParticles"),genParticleCollection);
	assert ( genParticleCollection.isValid() );
	// We don't know if it is a W, a Z, or neither
	// Iterate over genParticles
	const vector< reco::GenParticle>::const_iterator 
	  kGenPartEnd = genParticleCollection->end();
	for (vector< reco::GenParticle>::const_iterator gpIter =
	       genParticleCollection->begin(); 
	     gpIter != kGenPartEnd; ++gpIter ) 
	  {
	    if (gpIter->status() == 3 && std::abs(gpIter->pdgId()) == 23)
	      {
		sampleName += "Z";
		break;
	      }
	    else if (gpIter->status() == 3 && std::abs(gpIter->pdgId()) == 24)
	      {
		sampleName += "W";
		break;
	      }
	    else if (gpIter==kGenPartEnd-1) 
	      {
		sampleName += "X";
		break;
	      }
	  } // for  gpIter
	switch (HFcat_)
	  {
	    // from:
	    // https://twiki.cern.ch/twiki/bin/viewauth/CMS/SWGuideFlavorHistory
	    //  1. W+bb with >= 2 jets from the ME (dr > 0.5)
	    //  2. W+b or W+bb with 1 jet from the ME
	    //  3. W+cc from the ME (dr > 0.5)
	    //  4. W+c or W+cc with 1 jet from the ME
	    //  5. W+bb with 1 jet from the parton shower (dr == 0.0)
	    //  6. W+cc with 1 jet from the parton shower (dr == 0.0)
	    //  7. W+bb with >= 2 partons but 1 jet from the ME (dr == 0.0)
	    //  8. W+cc with >= 2 partons but 1 jet from the ME (dr == 0.0)
	    //  9. W+bb with >= 2 partons but 2 jets from the PS (dr > 0.5)
	    // 10. W+cc with >= 2 partons but 2 jets from the PS (dr > 0.5)
	    // 11. Veto of all the previous (W+ light jets)
	  case 1:
	    sampleName += "bb";
	    break;
	  case 2:
	    // Sometimes this is referred to as 'b' (e.g., 'Wb'), but I
	    // am using the suffix '2' to keep this case clear for when
	    // we have charm (see below).
	    sampleName += "b2";
	    break; 
	  case 3:
	    sampleName += "cc";
	    break;
	  case 4:
	    // We want to keep this case clear from real W + single charm
	    // produced (as opposed to two charm quarks produced and one
	    // goes down the beampipe), so we use 'c2' instead of 'c'.
	    sampleName += "c2";
	    break;
	  default:
	    // we don't want the rest of the cases.  Return an empty
	    // string so we know.
	    return false;
	  } // switch HFcat_
	return true;
      }
  
      // Normal Mode //
      else if (kNormalMode == mode)
	{
	  // all we want is the sample name, so in this case we're done.
	  return true;
	}
      else
	{
	  std::cout << "Error with naming sample" << std::endl;
	  return false;
	}
}

void SHyFT::finalize()
{
  wPlusJets.print(std::cout);
}



/// THE ACTUAL PROGRAM
int main ( int argc, char ** argv )
{
  // load framework libraries
  gSystem->Load( "libFWCoreFWLite" );
  AutoLibraryLoader::enable();

  // Setup a style                                                                                                                                                       
  gROOT->SetStyle ("Plain");

  if ( argc < 2 ) {
    std::cout << "Usage : " << argv[0] << " [parameters.py]" << std::endl;
    return 0;
  }

  // Get the python configuration
  PythonProcessDesc builder(argv[1]);
  boost::shared_ptr<edm::ProcessDesc> b = builder.processDesc();
  boost::shared_ptr<edm::ParameterSet> parameters = b->getProcessPSet();
  parameters->registerIt(); 
  edm::ParameterSet const& inputs  = parameters->getParameter<edm::ParameterSet>("inputs");
  edm::ParameterSet const& outputs = parameters->getParameter<edm::ParameterSet>("outputs");

  // book a set of histograms
  fwlite::TFileService fs = fwlite::TFileService( outputs.getParameter<std::string>("outputName") );
  TFileDirectory theDir = fs.mkdir( "histos" ); 
    
  SHyFT theAnalysis(*parameters,theDir);
  Preselection preselection( *parameters );

  fwlite::ChainEvent ev ( inputs.getParameter<std::vector<std::string> > ("fileNames") );

  unsigned int nEventsAnalyzed(0);

  // some timing
  TStopwatch timer;
  timer.Start();
  //loop through each event
  for( ev.toBegin();
       ! ev.atEnd();
       ++ev, ++nEventsAnalyzed) 
  {
    if (preselection.filter(ev))theAnalysis.analyze(ev);
    if (nEventsAnalyzed%10000==0) std::cout<<"Events analyzed: "<<nEventsAnalyzed<<std::endl;
  } //end event loop
  
  theAnalysis.finalize();

  timer.Stop();

  // print some timing statistics
  Double_t rtime = timer.RealTime();
  Double_t ctime = timer.CpuTime();
  printf("Analyzed events: %d \n",nEventsAnalyzed);
  printf("RealTime=%f seconds, CpuTime=%f seconds\n",rtime,ctime);
  printf("%4.2f events / RealTime second .\n", nEventsAnalyzed/rtime);
  printf("%4.2f events / CpuTime second .\n", nEventsAnalyzed/ctime);
  
  return 0;
}
